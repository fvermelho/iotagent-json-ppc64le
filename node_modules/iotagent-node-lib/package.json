{
  "_args": [
    [
      {
        "raw": "iotagent-node-lib@git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
        "scope": null,
        "escapedName": "iotagent-node-lib",
        "name": "iotagent-node-lib",
        "rawSpec": "git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
        "spec": "git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:dojot/iotagent-node-lib.git#cpqd_master",
          "sshUrl": "git+ssh://git@github.com/dojot/iotagent-node-lib.git#cpqd_master",
          "httpsUrl": "git+https://github.com/dojot/iotagent-node-lib.git#cpqd_master",
          "gitUrl": "git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
          "shortcut": "github:dojot/iotagent-node-lib#cpqd_master",
          "directUrl": "https://raw.githubusercontent.com/dojot/iotagent-node-lib/cpqd_master/package.json"
        }
      },
      "/opt/iotajson"
    ]
  ],
  "_from": "git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
  "_id": "iotagent-node-lib@2.4.0-next",
  "_inCache": true,
  "_location": "/iotagent-node-lib",
  "_phantomChildren": {
    "json-stringify-safe": "5.0.1",
    "lodash": "4.17.4",
    "serr": "0.3.0"
  },
  "_requested": {
    "raw": "iotagent-node-lib@git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
    "scope": null,
    "escapedName": "iotagent-node-lib",
    "name": "iotagent-node-lib",
    "rawSpec": "git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
    "spec": "git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:dojot/iotagent-node-lib.git#cpqd_master",
      "sshUrl": "git+ssh://git@github.com/dojot/iotagent-node-lib.git#cpqd_master",
      "httpsUrl": "git+https://github.com/dojot/iotagent-node-lib.git#cpqd_master",
      "gitUrl": "git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
      "shortcut": "github:dojot/iotagent-node-lib#cpqd_master",
      "directUrl": "https://raw.githubusercontent.com/dojot/iotagent-node-lib/cpqd_master/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/dojot/iotagent-node-lib.git#2d5469a88fa0581fc8e6b44fc5b5b092fef9200f",
  "_shasum": "17b46ffccabb862d5a5e23b021795dab12c3d064",
  "_shrinkwrap": null,
  "_spec": "iotagent-node-lib@git://github.com/dojot/iotagent-node-lib.git#cpqd_master",
  "_where": "/opt/iotajson",
  "author": {
    "name": "Daniel Moran",
    "email": "daniel.moranjimenez@telefonica.com"
  },
  "bin": {
    "agentConsole": "bin/agentConsole.js",
    "iotAgentTester": "bin/iotAgentTester.js"
  },
  "bugs": {
    "url": "https://github.com/telefonicaid/iotagent-node-lib/issues"
  },
  "dependencies": {
    "async": "^0.9.0",
    "body-parser": "^1.11.0",
    "command-shell-lib": "1.0.0",
    "express": "^4.11.2",
    "jison": "0.4.17",
    "logops": "1.0.0",
    "mongodb": "2.1.18",
    "mongoose": "4.6.8",
    "mu2": "^0.5.20",
    "mustache": "0.8.2",
    "node-uuid": "^1.4.1",
    "request": "^2.39.0",
    "revalidator": "^0.3.1",
    "sax": "^0.6.0",
    "underscore": "^1.7.0",
    "xmldom": "0.1.19"
  },
  "description": "IoT Agent library to interface with NGSI Context Broker",
  "devDependencies": {
    "chai": "~1.8.0",
    "closure-linter-wrapper": "1.0.1",
    "grunt": "0.4.5",
    "grunt-contrib-clean": "0.7.0",
    "grunt-contrib-jshint": "0.12.0",
    "grunt-contrib-watch": "0.6.1",
    "grunt-dox": "0.5.0",
    "grunt-exec": "0.4.6",
    "grunt-githooks": "0.5.0",
    "grunt-github-pages": "0.0.4",
    "grunt-gjslint": "0.2.1",
    "grunt-mkdir": "0.1.2",
    "grunt-mocha-test": "0.12.7",
    "grunt-plato": "^1.3.0",
    "istanbul": "~0.1.34",
    "mocha": "2.4.5",
    "nock": "*",
    "should": "8.2.2",
    "sinon": "~1.7.3",
    "sinon-chai": "2.4.0",
    "timekeeper": "0.0.5"
  },
  "engines": {
    "node": ">=0.10.8"
  },
  "gitHead": "2d5469a88fa0581fc8e6b44fc5b5b092fef9200f",
  "homepage": "https://github.com/telefonicaid/iotagent-node-lib",
  "keywords": [
    "fiware",
    "iotagent",
    "ngsi",
    "context broker"
  ],
  "main": "lib/fiware-iotagent-lib",
  "name": "iotagent-node-lib",
  "optionalDependencies": {},
  "readme": "# FIWARE IoT Agent Framework\n\n[![License badge](https://img.shields.io/badge/license-AGPL-blue.svg)](https://opensource.org/licenses/AGPL-3.0)\n[![Support badge]( https://img.shields.io/badge/support-sof-yellowgreen.svg)](http://stackoverflow.com/questions/tagged/fiware)\n\n## Index\n\n* [Overview](#overview)\n* [Build & Install](#buildinstall)\n* [API Overview](#apioverview)\n  * [About API](#aboutapi)\n  * [Device Provisioning API](#provisioningapi)\n  * [Configuration API](#configurationapi)\n* [Advanced Topics](#advancedtopics)\n  * [Secured access to the Context Broker](#securedaccess)\n  * [Data mapping plugins](#datamapping)\n  * [Old IoTAgent data migration](#datamigration)\n* [Testing](#librarytesting)\n* [Development Documentation](#development)\n\n## <a name=\"overview\"/> Overview\n### Description\nThis project aims to provide a Node.js module to enable IoT Agent developers to build custom agents for their devices that can\neasily connect to NGSI Context Brokers (such as [Orion](https://github.com/telefonicaid/fiware-orion) ). \n\nAn IoT Agent is a component that lets groups of devices send their data to and be managed from a FIWARE NGSI Context\nBroker using their own native protocols. IoT Agents should also be able to deal with security aspects of the Fiware\nplatform (authentication and authorization of the channel) and provide other common services to the device programmer.\n\nThere is more information about specific topics in the following documents:\n\n* [User manual](doc/usermanual.md): library reference for IoTA implementation. Contains the complete list of library\nfunctions and implementation topics.\n* [Installation and configuration guide](doc/installationguide.md): information for the configuration of the library.\n* [Operations manual](doc/operations.md): guide of logs and alarms raised by the library.\n* [IoTA Design HowTo](doc/howto.md): step-by-step howto about how to implement an IoT Agent.\n\nThis project is part of [FIWARE](https://www.fiware.org/). Check also the [FIWARE Catalogue entry for the IoTAgents](http://catalogue.fiware.org/enablers/backend-device-management-idas)\n\n### Device to NGSI Mapping\nEach Device will be mapped as an Entity associated to a Context Provider: the Device Id will be mapped by default to\nthe entity ID and the type of the entity will be selected by the IoT Agent in a protocol-dependent way (e.g: with\ndifferent URLs for different types). Both the name and type will be configurable by the user, either by type\nconfiguration or with the device preprovisioning.\n\nEach of the measures obtained from the device should be mapped to a different attribute. The name and type of the\nattribute will be configured by the user (globally for all the types in the IoT Agent configuration or in a per device\nbasis preprovisioning the devices). Device measures can have three different behaviors:\n\n* **Active attributes**: are measures that are pushed from the device to the IoT agent. This measure changes will be\nsent to the Context Broker as updateContext requests over the device entity. NGSI queries to the context broker will\nbe resolved in the Broker database.\n\n* **Lazy attributes**: some sensors will be passive, and will wait for the IoT Agent to request for data. For those\nmeasures, the IoT Agent will register itself in the Context Broker as a Context Provider (for all the lazy measures of\nthat device), so if any component asks the Context Broker for the value of that sensor, its request will be redirected\nto the IoT Agent (that behaves as a NGSI10 Context Provider). This operation will be synchronous from the customer\nperspective: the Context Broker won't return a response until de device has returned its response to the IoT Agent.\n\n* **Commands**: in this case, the interaction will begin by setting an attribute in the device's entity, for which the\nIoT Agent will be regitered as CP. The IoT Agent will return an immediate response to the Context Broker, and will be\nheld responsible of contacting the device to perform the command itself, updating special `status` and `info` attributes\nin the entity as soon as it has any information of the command progress.\n\nThe following sequence diagram shows the different NGSI interactions an IoT Agent makes with the Context Broker,\nexplained in the following subsections (using the example of a OMA Lightweight M2M device).\n\n![General ](https://raw.githubusercontent.com/telefonicaid/iotagent-node-lib/master/img/ngsiInteractions.png \"NGSI Interactions\")\n\nBe aware that the IoT Agents are only required to support NGSI10 operations `updateContext` and `queryContext` in their\nstandard formats (currently in JSON format; XML deprecated) but will not answer to NGSI9 operations\n(or NGSI convenience operations of any kind).\n\n#### Configurations and Device provisioning information\nIn order for a device to connect to the IoTA, the device should be provisioned (although there may be occasions where this\nregistration is not needed). The provision process is meant to provide the IoTA with the following information:\n\n* **Entity translation information**: information about how to convert the data coming from the South Bound into NGSI\ninformation. This includes things as the entity name and type and the name and type of all the attributes that will\nbe created in the entity. This includes the service and subservice the entity belongs to.\n\n* **Southbound protocol identification**: attributes that will identify a particular device when a new measure comes to\nthe Southbound (typically the Device ID and API Key).\n\n* **Security information**: trust token for the devices to be inserted in a PEP Protected Context Broker.\n\n* **Other information**: as timezone or alternative Context Brokers.\n\nIn order to provide this information, the IoTAgent Northbound API provides two resources: Device and Configuration\nprovisioning.\n\n**Configurations** may be used when a set of similar devices will be connected to the IoTA, to avoid provisioning the\nsame set of information for every device. Custom APIKeys can be only provided with the use of Configurations for device\ngroups. When a device is provisioned, it is assigned to a configuration *if there is one that matches its type, its service\nand its subservice*. In that case, all the default information in the Configuration is merged with the device information\nto create the definitive Device object that will be stored in the system.\n\nParticular IoT Agents *may* support autoregistration of devices into configurations, if enough information is given from\nthe Southbound.\n\n#### Configurations and subservices\n\nConfigurations are meant to be a mean of simplifying the device provisioning for groups of very similar devices. Considering\nthat different groups of devices may be created in the same subservice that may require different configurations, multiple\nconfigurations are allowed for each subservice. Considering the key in the association between Device and Configuration\nwas the triplet (service, subservice, type), all of these elements are considered mandatory.\n\nThis statement doesn't hold true for older IoT Agents, though. In older versions of the IoT Agents, each device\nconfiguration was assigned to a particular subservice and just one configuration was allowed per subservice, so the relation\nbetween a Device and a Configuration didn't need the type to discriminate between Configurations. That's why for those\nagents, type was not a mandatory parameter.\n\nIn order to allow backward-compatibility with those agents, the IoT Agent Library now implement a compatibility mode:\nthe **Single Configuration Mode**, that makes the agent behave like the old agents. In this mode:\n\n* Each Subservice can contain just one Configuration. If a second Configuration is created for a Subservice, an error\nis raised.\n\n* Each Device provisioned for a Subservice is automatically assigned to the Subservice one Configuration if there is any.\n\nThis compatibility has to be set for the whole IoT Agent, and there is no option of having both modes simultaneously running.\nTransitions from one mode to the other should be made with care, and may involve data migration.\n\n#### Registration\nWhenever a device is registered, the IoT Agent reads the device's entity information from the request or, if that\ninformation is not in the request, from the default values for that type of device. Among this information, there should\nbe the list of device attributes that will be considered lazy (or passive). With this information, the IoT Agent sends\na new `registerContext` request to the Context Broker, registering itself as ContextProvider of all the lazy attributes\nfor the device's entity. The `registrationId` is then stored along the other device information inside the IoT Agent\ndevice registry.\n\nAs NGSI9 does not allow the context registrations to be removed, when the device is removed from the IoT Agent, the\nregistration is updated to an expiration date of 1s, so it is effectively disabled. Once it has been disabled, the device\nis removed from the IoT Agent's internal registry.\n\n#### Lazy attributes\nWhen a request for data from a lazy attribute arrives to the Context Broker, it forwards the request to the Context\nProvider of that entity, in this case the IoT Agent. The IoT Agent will in turn ask the device for the information needed,\ntransform that information to a NSGI format and return it to the Context Broker. The latter will the forward the response\nto the caller, transparently.\n\n#### Commands\nCommands are modelled as updates over a lazy attribute. As in the case of the lazy attributes, updates over a command\nwill be forwarded by the Context Broker to the IoT Agent, that will in turn interact with the device to perform the\nrequested action. Parameters for the command will be passed inside the command value.\n\nThere are two differences with the lazy attributes:\n* First of all, for every command defined in a device, two new attributes are created in the entity with the same name\nas the command but with a prefix:\n\t* '_info': this attribute reflect the current execution status of the command. When a command request is issued by\n\tthe Context Broker, the IoT Agent library generates this attribute with 'PENDING' value. The value of this attribute\n\twill be changed each time a command error or result is issued to the IoT Agent.\n\t* '_result': this attribute reflect the result of the execution of the defined command.\n\n* Commands can also be updated when new information about its execution arrives to the agent. This information will be\nmapped to the command's utility attributes `_info` and `_result` leaving alone the command attribute itself. The\nvalues for this attributes are stored locally in the Context Broker (instead of being redirected with the Context\nProvider operations).\n\nThere are two types of commands:\n* **Push commands**: when a command of this type arrives to the IoTAgent, the IoTAgent will immediately forward the command\nrequest to the device, translating the request to the proper protocol (that will depend on the type of IoTAgent). The\nlibrary implement this kind of commands by offering a set functions that can be used to set an IoTAgent-specific handler\nfor incoming commands. In order for this type of commands to work properly, the devices must be preprovisioned with an\nendpoint of the proper protocol, where it can be accessed by the IoTAgent who pushes de commits.\n\n* **Poll commands**: polling commands are meant to be used on those cases where the device can't be online the whole time\nwaiting for commands. In this case, the IoTAgents must store the received commands, offering a way for the device to\nretrieve the pending commands upon connection. To enable this feature, the Library offers a set of functions to manage\ncommand storage, and a mechanism to automatically store incoming commands for those devices marked as 'polling devices'.\n\nThe distinction between push and poll commands will be made based on the presence of a `polling` flag in the device\nprovisioning data. The default option (with the flag with value `false` or not present) is to use push commands (as they\nwere the only ones available until the latest versions).\n\nPolling commands could be subjected to expiration: two configuration properties pollingExpiration` and `pollingDaemonFrequency`\ncan be set to start a daemon that will remove expired commands from the DB if the device is taking too much to pick them\nup. See the configuration section for details.\n\nThe library does not deal with protocol transformation or South Bound communications for neither of the command types\n(that's the task for those specific IoTAgents using the library).\n\n#### Active attributes\nWhenever a device proactively sends a message to the IoT Agent, it should tranform its data to the appropriate NGSI\nformat, and send it to the Context Broker as an `updateContext` request.\n\n### Features\nThese are the features an IoT Agent is supposed to expose (those not supported yet by this library are marked as PENDING):\n\n* **Device registration**: multiple devices will be connected to each IoT Agent, each one of those mapped to a\nCB entity. The IoT Agent will register itself as a Context Provider for each device, answering to requests and updates\non any lazy attribute of the device.\n\n* **Device information update**: whenever a device haves new measures to publish, it should send the information to\nthe IoT Agent in its own native language. This message should , in turn, should be sent as an `updateContext` request to\nthe Context Broker, were the measures will be updated in the device entity.\n\n* **Device command execution and value updates**: as a Context Provider, the IoT Agent should receive update operations\nfrom the Context Broker subscriptions, and relay them to the corresponding device (decoding it using its ID and Type,\nand other possible metadata). This commands will arrive as `updateContext` operations redirected from the Context Broker\nto the IoT Agent (Command execution PENDING; value updates available).\n\n* **Device management**: the IoT Agent should offer a device repository where the devices can be registered, holding data\n needed for the connection to the Context Broker as the following: service and subservice for the device, API Key the\n device will be using to connect to the IoT Agent, Trust token the device will be using to retrieve the Keystone token\n to connect to the Context Broker.\n\n* **Device provisioning**: the IoT Agent should offer an external API to make a preprovision of any devices. This\npreprovision should enable the user to customize the device`s entity name and type as well as their service information.\n\n* **Type configuration**: if a device is registered without a preregistration, only its `id` and `type` attributes are\nmandatory. The IoT Agent should provide a mechanism to provide default values to the device attributes based on its\ntype.\n\nAlmost all of these features are common for every agent, so they can be abstracted into a library or external module.\nThe objective of this project is to provide that abstraction. As all this common tasks are abstracted, the main task of\nthe concrete IoT Agent implementations will be to map between the native device protocol and the library API.\n\nThe following figure offers a graphical example of how a COAP IoT Agent work, ordered from the registration of the device\nto a command update to the device.\n\n![General ](https://raw.githubusercontent.com/telefonicaid/iotagent-node-lib/master/img/iotAgentLib.png \"Architecture Overview\")\n\n### <a name=\"TimeInstant\"/>The ´TimeInstant´ element\n\nAs part of the device to entity mapping process the IoT Agent creates and updates automatically a special timestamp.\nThis timestamp is represented as two different properties of the mapped entity::\n\n* An attribute metadata named `TimeInstant` per dynamic attribute mapped, which captures as an ISO8601 timestamp when\nthe associated measurement (represented as attribute value) was observed.\n\n* An entity attribute named `TimeInstant` which captures as an ISO8601 timestamp when the last measurement received\nfrom the device was observed.\n\nIf no information about the measurement timestamp is received by the IoTAgent, the arrival time of the measurement will\nbe used to generate a `TimeInstant` for both the entity and the attribute's metadata.\n\nTake into account that:\n* the timestamp of different attributes belonging to the same measurement record may not be equal.\n* the arrival time and the measurement timestamp will not be the same in the general case.\n\nE.g.: in the case of a device that can take measurements every hour of both temperature and humidity and sends the data\nonce every day, at midnight, the `TimeInstant` reported for each measurement will be the hour when that measurement was observed\n(e.g. 4:00 PM), while all the measurements will have an arrival time around midnight. If no timestamps were reported with\nsuch measurements, the `TimeInstant` attribute would take those values around midnight.\n\nThis functionality can be turned on and off through the use of the `timestamp` configuration flag (described in the\nconfiguration).\n\n### Implementation decisions\nGiven the aforementioned requirements, there are some aspects of the implementation that were chosen, and are\nparticularly under consideration:\n* Aside from its configuration, the IoT Agent Lib is considered to be stateless. To be precise, the library\nmantains a state (the list of entities/devices whose information the agent can provide) but that state is considered\nto be transient. It's up to the particular implementation of the agent to consider whether it should have a persistent\nstorage to hold the device information (so the internal list of devices is read from a DB) or to register the devices\neach time a device sends a measure. To this extent, two flavours of the Device Registry has been provided: a transient\none (In-memory Registry) and a persistent one (based in MongoDB).\n* The IoT Agent does not care about the origin of the data, its type or structure. The mapping from raw data to the\nentity model, if there is any, is a responsability of the particular IoT Agent implementation, or of another third\nparty library.\n\n## <a name=\"buildinstall\"/> Build & Install\n\nInformation about how to configure the Library can be found at the corresponding section of the [Installation & Administration Guide](docs/installationguide.md).\n\nThis library has no packaging or build processes. Usage of the library is explained in the [User & Programmers Manual](docs/usermanual.md).\n\n## <a name=\"apioverview\"/> API Overview\n\n### <a name=\"aboutapi\"/> About API\nThe library provides a simple operation to retrieve information about the library and the IoTA using it. A GET request\nto the `/iot/about` path, will show a payload like the following:\n```\n{\n“version”:”0.5.2”,\n“libVersion”:”0.8.4”,\n\"port\":4041,\n\"baseRoot\":\"/\"\n}\n```\nthe `version` field will be read from the `iotaVersion` field of the config, if it exists.\n\n### <a name=\"provisioningapi\"/> Device Provisioning API\n#### Overview\nThe IoT Agents offer a provisioning API where devices can be preregistered, so all the information about service and \nsubservice mapping, security information and attribute configuration can be specified in a per device way instead of \nrelaying on the type configuration. The following section specifies the format of the device payload; this will be the \npayload accepted by all the write operations and that will be returned by all the read operations. Take care of the \nexception of the POST operation: in this case, the device objects must be specified as an array, as multiple devices\ncan be provided simultaneusly for the same service.\n\nTwo parameters in this payload are given a special treatment: service and subservice. This two parameters are needed to \nfill the `fiware-service` and `fiware-servicepath` mandatory headers that will be used in the interactions with the \nContext Broker. This parameters should not be passed along with the rest of the body, but they will be taken from the \nsame headers, as received by the Device Provisioning API (this two headers are, thus, mandatory both for incoming and \noutgoing requests).\n\nNote that there is a 1:1 correspondence between payload fields and DB fields (but using a different capitalization, \ne.g. `service_path` vs. `servicePath`).\n\n#### Device model\n\nThe next table shows the information held in the Device resource. The table also contains the correspondence between\nthe API resource fields and the same fields in the database model.\n\n| Payload Field | DB Field | Definition                                     | Example of value                      |\n| ------------------- | ------------------- |:---------------------------------------------- |:------------------------------------- |\n| device_id    \t      | id    \t      | Device ID that will be used to identify the device. | UO834IO   |\n| service             | service            |  Name of the service the device belongs to (will be used in the fiware-service header).  | smartGondor |\n| service_path        | subservice        | Name of the subservice the device belongs to (used in the fiware-servicepath header). | /gardens |\n| entity_name         | name         | Name of the entity representing the device in the Context Broker\t| ParkLamplight12 |\n| entity_type         | type         | Type of the entity in the Context Broker | Lamplights |\n| timezone            | timezone            | Time zone of the sensor if it has any | America/Santiago |\n| endpoint            | endpoint            | Endpoint where the device is going to receive commands, if any. | http://theDeviceUrl:1234/commands  |\n| protocol            | protocol            | Name of the device protocol, for its use with an IoT Manager. | IoTA-UL |\n| transport           | transport           | Name of the device transport protocol, for the IoT Agents with multiple transport protocols. | MQTT |\n| attributes          | active          | List of active attributes of the device\t| `[ { \"name\": \"attr_name\", \"type\": \"string\" } ]` |\n| lazy                | lazy                | List of lazy attributes of the device\t| `[ { \"name\": \"attr_name\", \"type\": \"string\" } ]` |\n| commands            | commands            | List of commands of the device\t| `[ { \"name\": \"attr_name\", \"type\": \"string\" } ]` |\n| internal_attributes | internalAttributes | List of internal attributes with free format for specific IoT Agent configuration | LWM2M mappings from object URIs to attributes |\n| static_attributes   | staticAttributes   | List of static attributes to append to the entity. All the updateContext requests to the CB will have this set of attributes appended.\t| `[ { \"name\": \"attr_name\", \"type\": \"string\" } ]` |\n\n#### Attribute lists\nIn the device model there are three list of attributes that can be declared: attributes, lazy and commands. All of them \nhave the same syntax, an object containing the following attributes:\n* **object_id** (optional): name of the attribute as coming from the device.\n* **name** (mandatory): id of the attribute in the target entity in the Context Broker.\n* **type** (mandatory): name of the type of the attribute in the target entity.\n\nSome transformation plugins also allow the use of the following optional attributes:\n* **expression**: indicates that the value of the target attribute will not be the plain value or the measurement, but\nan expression based on a combination of the reported values. See the [Expression Language definition](doc/expressionLanguage.md) for details\n* **entity_name**: the presence of this attribute indicates that the value will not be stored in the original device entity\nbut in a new entity with an ID given by this attribute. The type of this additional entity can be configured with the\n`entity_type` attribute. If no type is configured, the device entity type is used instead. Entity names can be defined\nas expressions, using the [Expression Language definition](doc/expressionLanguage.md).\n* **entity_type**: configures the type of an alternative entity.\n* **reverse**: add bidirectionality expressions to the attribute. See the **bidirectionality** transformation plugin\nin the [Data Mapping Plugins section](#datamapping) for details.\n\nSee the transformation plugins Section for more details.\n\n#### API Actions\n##### POST /iot/devices\nProvision a new device in the IoT Agent's device registry. Takes a Device in JSON format as the payload. \n\nReturns: \n* 200 OK if successful.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\nPayload example:\n```json\n{\n    \"devices\": [ \n        { \n            \"device_id\": \"DevID1\", \n            \"entity_name\": \"TheDevice1\", \n            \"entity_type\": \"DeviceType\", \n            \"attributes\": [ \n                  { \"object_id\": \"t\", \"name\": \"temperature\", \"type\": \"float\" },\n                  { \"object_id\": \"h\", \"name\": \"humidity\", \"type\": \"float\" }\n            ],\n            \"lazy\":[\n                  { \"object_id\": \"l\", \"name\": \"luminosity\", \"type\": \"percentage\" }\n            ],\n            \"commands\": [\n                  { \"object_id\": \"t\", \"name\": \"turn\", \"type\": \"string\" }\n            ],\n            \"static_attributes\": [\n                  { \"name\": \"serialID\", \"type\": \"02598347\" }\n            ]\n        }\n    ]\n}\n```\n\n##### GET /iot/devices\nReturns a list of all the devices in the device registry with all its data.\n\nQuery parameters:\n* limit: if present, limits the number of devices returned in the list.\n* offset: if present, skip that number of devices from the original query.\n\nReturns: \n* 200 OK if successful, and the selected Device payload in JSON format.\n* 404 NOT FOUND if the device was not found in the database.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\nExample of return payload:\n```json\n{\n  \"count\": 2,\n  \"devices\": [\n    {\n      \"device_id\": \"DevID0\",\n      \"service\": \"ServiceTest\",\n      \"service_path\": \"/testSubservice\",\n      \"entity_name\": \"TheDevice0\",\n      \"entity_type\": \"DeviceType\",\n      \"attributes\": [\n        {\n          \"type\": \"float\",\n          \"name\": \"temperature\",\n          \"object_id\": \"t\"\n        },\n        {\n          \"type\": \"float\",\n          \"name\": \"humidity\",\n          \"object_id\": \"h\"\n        }\n      ],\n      \"lazy\": [],\n      \"static_attributes\": [],\n      \"internal_attributes\": []\n    },\n    {\n      \"device_id\": \"DevID1\",\n      \"service\": \"ServiceTest\",\n      \"service_path\": \"/testSubservice\",\n      \"entity_name\": \"TheDevice1\",\n      \"entity_type\": \"DeviceType\",\n      \"attributes\": [\n        {\n          \"type\": \"float\",\n          \"name\": \"temperature\",\n          \"object_id\": \"t\"\n        },\n        {\n          \"type\": \"float\",\n          \"name\": \"humidity\",\n          \"object_id\": \"h\"\n        }\n      ],\n      \"lazy\": [\n        {\n          \"type\": \"percentage\",\n          \"name\": \"luminosity\",\n          \"object_id\": \"l\"\n        }\n      ],\n      \"static_attributes\": [\n        {\n          \"type\": \"02598347\",\n          \"name\": \"serialID\"\n        }\n      ],\n      \"internal_attributes\": []\n    }\n```\n\n##### GET /iot/devices/:deviceId\nReturns all the information about a particular device.\n\nReturns: \n* 200 OK if successful, and the selected Device payload in JSON format.\n* 404 NOT FOUND if the device was not found in the database.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\nExample of return payload:\n```json\n{\n  \"device_id\": \"DevID1\",\n  \"service\": \"ServiceTest\",\n  \"service_path\": \"/testSubservice\",\n  \"entity_name\": \"TheDevice1\",\n  \"entity_type\": \"DeviceType\",\n  \"attributes\": [\n    {\n      \"object_id\": \"t\",\n      \"name\": \"temperature\",\n      \"type\": \"float\"\n    },\n    {\n      \"object_id\": \"h\",\n      \"name\": \"humidity\",\n      \"type\": \"float\"\n    }\n  ],\n  \"lazy\": [\n    {\n      \"object_id\": \"l\",\n      \"name\": \"luminosity\",\n      \"type\": \"percentage\"\n    }\n  ],\n  \"static_attributes\": [\n    {\n      \"name\": \"serialID\",\n      \"type\": \"02598347\"\n    }\n  ],\n  \"internal_attributes\": []\n}\n```\n\n##### DELETE /iot/devices/:deviceId\nRemove a device from the device registry. No payload is required or received.\n\nReturns: \n* 200 OK if successful, with no payload.\n* 404 NOT FOUND if the device was not found in the database.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\n##### PUT /iot/devices/:deviceId\nChanges the stored values for the device with the provided Device payload. Neither the name, the type nor the ID of the\ndevice can be changed using this method (as they are used to link the already created entities in the CB to the information\nin the device). Service and servicepath, being taken from the headers, can't be changed also.\n\nReturns: \n* 200 OK if successful, with no payload.\n* 404 NOT FOUND if the device was not found in the database.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\nPayload example:\n```json\n{ \n    \"attributes\": [ \n          { \"object_id\": \"t\", \"name\": \"temperature\", \"type\": \"float\" },\n          { \"object_id\": \"h\", \"name\": \"humidity\", \"type\": \"float\" },\n          { \"object_id\": \"p\", \"name\": \"pressure\", \"type\": \"float\" }\n    ],\n    \"lazy\":[\n          { \"object_id\": \"l\", \"name\": \"luminosity\", \"type\": \"percentage\" }\n    ],\n    \"commands\": [\n          { \"object_id\": \"t\", \"name\": \"turn\", \"type\": \"string\" }\n    ],\n    \"static_attributes\": [\n          { \"name\": \"serialID\", \"type\": \"02598347\" }\n    ]\n}\n```\n\n### <a name=\"configurationapi\"/> Configuration API\nFor some services, there will be no need to provision individual devices, but it will make more sense to provision\ndifferent device groups, each of one mapped to a different type of entity in the context broker. How the type of entity\nis assigned to a device will depend on the Southbound technology (e.g.: path, port, APIKey...). Once the device has an\nassigned type, its configuration values can be extracted from those of the type.\n\nThe IoT Agents provide two means to define those device groups:\n* Static **Type Configuration**: configuring the `ngsi.types` property in the `config.js` file.\n* Dynamic **Configuration API**: making use of the API URLS in the configuration URI, `/iot/services`. Please, note\nthat the configuration API manage servers under an URL that requires the `server.name` parameter to be set (the name of\nthe IoT Agent we are using). If no name is configured `default` is taken as the default one.\n\nBoth approaches provide the same configuration information for the types (and they, in fact, end up in the same\nconfiguration collection).\n\nBoth approaches are better described in the sections bellow. \n\n#### Configuration API\nThe following sections show the available operations for the Configuration API. Every operation in the API require the `fiware-service` and `fiware-servicepath` to be defined; the operations are performed in the scope of those headers. For the list case, the special wildcard servicepath can be specified, '/*'. In this case, the operation applies to all the subservices of the service given by the `fiware-service` header.\n\nFor every Device Group, the pair (resource, apikey) *must* be unique (as it is used to identify which group to assign to which device). Those operations of the API targeting specific resources will need the use of the `resource` and `apikey` parameters to select the apropriate instance.\n\nNote that there is a 1:1 correspondence between payload fields and DB fields (but with some changes in the attribute\nnaming; e.g.: subservice -> service_path).\n\n##### Device Group Model\nThe next table shows the information held in the Device Group resource. The table also contains the correspondence between\nthe API resource fields and the same fields in the database model.\n\n| Payload Field | DB Field | Definition                                     |\n| ------------------- | ------------------- |:---------------------------------------------- |\n| service    \t        | service    \t        | Service of the devices of this type |\n| subservice    \t    | subservice    \t    | Subservice of the devices of this type. |\n| resource    \t      | resource    \t      | string representing the Southbound resource that will be used to assign a type to a device (e.g.: pathname in the southbound port). |\n| apikey    \t        | apikey    \t        | API Key string. |\n| entity_type    \t    | entity_type    \t    | name of the type to assign to the group. |\n| trust    \t          | trust    \t          | trust token to use for secured access to the Context Broker for this type of devices (optional; only needed for secured scenarios). |\n| cbHost    \t        | cbHost    \t        | Context Broker connection information. This options can be used to override the global ones for specific types of devices. |\n| lazy    \t          | lazy    \t          | list of lazy attributes of the device. For each attribute, its `name` and `type` must be provided. |\n| commands    \t      | commands    \t      | list of commands attributes of the device. For each attribute, its `name` and `type` must be provided. |\n| active    \t        | attributes    \t    | list of active attributes of the device. For each attribute, its `name` and `type` must be provided. |\n| static_attributes   | staticAttributes    | this attributes will be added to all the entities of this group 'as is'. |\n| internal_attributes | internalAttributes  | optional section with free format, to allow specific IoT Agents to store information along with the devices in the Device Registry. |\n\n\n##### POST /iot/services\nCreates a set of device groups for the given service and service path. The service and subservice information will taken from the headers, overwritting any preexisting values.\n\nBody params:\n* services: list of device groups to create. Each one adheres to the Device Group Model.\n\nE.g.:\n```\n{\n\t\"services\": [\n\t{\n\t    \"resource\": \"/deviceTest\",\n\t    \"apikey\": \"801230BJKL23Y9090DSFL123HJK09H324HV8732\",\n\t    \"type\": \"Light\",\n\t    \"trust\": \"8970A9078A803H3BL98PINEQRW8342HBAMS\",\n\t    \"cbHost\": \"http://unexistentHost:1026\",\n\t    \"commands\": [\n\t        {\n\t            \"name\": \"wheel1\",\n\t            \"type\": \"Wheel\"\n\t        }\n\t    ],\n\t    \"lazy\": [\n\t        {\n\t            \"name\": \"luminescence\",\n\t            \"type\": \"Lumens\"\n\t        }\n\t    ],\n\t    \"active\": [\n\t        {\n\t            \"name\": \"status\",\n\t            \"type\": \"Boolean\"\n\t        }\n\t    ]\n\t}\n\t]\n}\n```\n\nReturns: \n* 200 OK if successful, with no payload.\n* 400 MISSING_HEADERS if any of the mandatory headers is not present.\n* 400 WRONG_SYNTAX if the body doesn't comply with the schema.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\n##### GET /iot/services\nRetrieves device groups from the database. If the servicepath header has de wildcard expression, '/*', all the subservices for the service are returned. The specific subservice parameters are returned in any other case.\n\nReturns: \n* 200 OK if successful, returning a device group body.\n* 400 MISSING_HEADERS if any of the mandatory headers is not present.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\n##### PUT /iot/services\nModifies the information for a device group configuration, identified by the `resource` and `apikey` query parameters. Takes a device group body as the payload. The body does not have to be complete: for incomplete bodies, just the existing attributes will be updated\n\nE.g.:\n```\n{\n    \"trust\": \"8970A9078A803H3BL98PINEQRW8342HBAMS\",\n    \"cbHost\": \"http://anotherUnexistentHost:1026\"\n}\n```\n\nReturns: \n* 200 OK if successful, returning the updated body.\n* 400 MISSING_HEADERS if any of the mandatory headers is not present.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\n##### DELETE /iot/services\nRemoves a device group configuration from the DB, specified by the `resource` and `apikey` query parameters. \n\nReturns: \n* 200 OK if successful.\n* 400 MISSING_HEADERS if any of the mandatory headers is not present.\n* 500 SERVER ERROR if there was any error not contemplated above.\n\n#### Type Configuration\nThe IoT Agent can be configured to expect certain kinds of devices, with preconfigured sets of attributes, service information, security information and other attributes. The `types` attribute of the configuration is a map, where the key is the type name and the value is an object containing all the type information. Each type can has the following information configured:\n\n* **service**: service of the devices of this type.\n* **subservice**: subservice of the devices of this type.\n* **active**: list of active attributes of the device. For each attribute, its `name` and `type` must be provided.\n* **lazy**: list of lazy attributes of the device. For each attribute, its `name` and `type` must be provided.\n* **commands**: list of commands attributes of the device. For each attribute, its `name` and `type` must be provided.\n* **internalAttributes**: optional section with free format, to allow specific IoT Agents to store information along with the devices in the Device Registry.\n* **staticAttributes**: this array of attributes will be added to every entity of this type 'as is'.\n* **trust**: trust token to use for secured access to the Context Broker for this type of devices (optional; only needed for secured scenarios).\n* **cbHost**: Context Broker host url. This option can be used to override the global CB configuration for specific types of devices.\n\n## <a name=\"advancedtopics\"/> Advanced Topics\n### <a name=\"securedaccess\"/> Secured access to the Context Broker\nFor access to instances of the Context Broker secured with a [PEP Proxy](https://github.com/telefonicaid/fiware-orion-pep), an authentication mechanism based in Keystone Trust tokens is provided. A Trust token is a long-term token that can be issued by any user to give another user permissions to impersonate him with a given role in a given project.\n\nFor the authentication mechanisms to work, the `authentication` attribute in the configuration has to be fully configured, and the `authentication.enabled` subattribute should have the value `true`.\n\nWhen the administrator of a service is configuring a set of devices or device types in the IoT Agent to use a secured Context Broker, he should follow this steps:\n* First, a Trust token should be requested to Keystone, using the service administrator credentials, the role ID and the IOT Agent User ID. The Trust token can be retrieved using the following request (shown as a curl command):\n```\ncurl http://${KEYSTONE_HOST}/v3/OS-TRUST/trusts \\\n    -s \\\n    -H \"X-Auth-Token: $ADMIN_TOKEN\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '\n{\n    \"trust\": {\n        \"impersonation\": false,\n        \"project_id\": \"'$SUBSERVICE_ID'\",\n        \"roles\": [\n            {\n                \"id\": \"'$ID_ROLE'\"\n            }\n        ],\n        \"trustee_user_id\": \"'$ID_IOTAGENT_USER'\",\n        \"trustor_user_id\": \"'$ID_ADM1'\"\n    }\n}'\n```\n* Every device or type of devices configured to use a secured Context Broker must be provided with a Trust Token in its configuration.\n* Before any request is sent to a secured Context Broker, the IoT Agent uses the Trust token to generate a temporary access token, that is attached to the request (in the `X-Auth-token` header).\n\nApart from the generation of the trust, the use of secured Context Brokers should be transparent to the user of the IoT Agent.\n\n### <a name=\"datamapping\"/> Data mapping plugins\n#### Overview\nThe IoT Agent Library provides a plugin mechanism in order to facilitate reusing code that makes small transformations on \nincoming data (both from the device and from the context consumers). This mechanism is based in the use of middlewares,\ni.e.: small pieces of code that receive and return an `entity`, making as many changes as they need, but taking care of\nreturning a valid entity, that can be used as the input for other middlewares; this way, all those pieces of\ncode can be chained together in order to make all the needed transformations in the target entity.\n\nThere are two kinds of middlewares: updateContext middlewares and queryContext middlewares. The updateContext middlewares\nare applied before the information is sent to the Context Broker, modifiying the entity before it is sent to Orion. The \nqueryContext middlewares are applied on the received data, whenever the IoT Agent queries the Context Broker for information.\nI.e.: both middlewares will be automatically applied whenever the `update()` or `query()` functions are called in the \nlibrary.\n\nAll the middlewares have the opportunity to break the chain of middleware applications by calling the `callback()` with\nan error object (the usual convention). If any of the updateContext middlewares raise an error, no request will be sent\nto the Context Broker. On the other hand, the queryContext request is always performed, but the call to the `query()` \nfunction will end up in an error if any of the queryContext middlewares report an error.\n\n#### Development\nAll the middlewares have the same signature:\n```\nfunction middlewareName(entity, typeInformation, callback) {}\n```\nThe arguments for any middleware are the NGSI data over which it can operate:\n- An updateContext payload in the case of an updateContext middleware and a queryContext payload otherwise; \n- a typeInformation object containing all the information about the device stored during registration.\n- and the customary `callback` parameter, with the usual meaning. It's really important for the library user to call \nthis callback, as failing to do so may hang the IoT Agent completely. The callback must be called with the an optional \nerror in the first argument and the same arguments recieved (potentially modified) as the following.\n\nIn order to manage the middlewares to the system, the following functions can be used:\n- `addUpdateMiddleware`: adds an updateContext middleware to the stack of middlewares. All the middlewares will be \napplied to every call to the `update()` function. The final payload of the updateContext request will be the result\nof applying all this middlewares in the order they have been defined.\n\n- `addQueryMiddleware`: adds a queryContext middleware to the stack of middlewares. All the middlewares will be applied \nto every call to the `query()` function.\n\n- `resetMiddlewares`: remove all the middlewares from the system.\n\nUsually, the full list of middlewares an IoT Agent will use would be added in the IoTAgent start sequence, so they \nshould not change a lot during the IoT lifetime.\n\n#### Provided plugins\nThe library provides some plugins out of the box, in the `dataPlugins` collection. In order to load any of them, just\nuse the `addQueryMiddleware` and `addUpdateMiddleware` functions with the selected plugin, as in the example:\n```\nvar iotaLib = require('iotagent-node-lib');\n\niotaLib.addUpdateMiddleware(iotaLib.dataPlugins.compressTimestamp.update);\niotaLib.addQueryMiddleware(iotaLib.dataPlugins.compressTimestamp.query);\n```\n\n##### Timestamp Compression plugin (compressTimestamp)\nThis plugins change all the timestamp attributes found in the entity, and all the timestamp metadata found in any \nattribute, from the basic complete calendar timestamp of the ISO8601 (e.g.: 20071103T131805) to the extended\ncomplete calendar timestamp (e.g.: +002007-11-03T13:18). The middleware expects to receive the basic format in \nupdates and return it in queries (and viceversa, receive the extended one in queries and return it in updates).  \n\n##### Attribute Alias plugin (attributeAlias)\nIn the Device provision, an id can be specified for each attribute, along with its name. The Id can be used then as \nthe left part of a mapping from attribute names in the south bound to attribute names in the North Bound. If the id and\nname attributes are used in this way, this plugin makes the translation from one to the other automatically.\n\n##### Event plugin (addEvents)\nThis plugin allows for the creation of Event attributes, i.e.: attributes whose value will be the timestamp of its\ninclusion in the system, regardless of the value they carried in the Southbound API. If this plugin is active, all\nthe events in the IoT Agent with the configured type name will be marked as events. The event name can be configured\nin the `config.eventType` attribute.\n\n##### Timestamp Processing Plugin (timestampProcess)\nThis plugin processes the entity attributes looking for a TimeInstant attribute. If one is found, the plugin add a\nTimeInstant attribute as metadata for every other attribute in the same request.\n\n##### Expression Translation plugin (expressionTransformation)\nThis plugin allows the devices and configurations that have defined expressions to generate their values from those\nexpressions and the reported measure information.\n\nFor further information on how the expressions work, refer to the [Expression Language Reference](.doc/expressionLanguage).\n\n##### Multientity plugin (multiEntity)\nAllows the devices provisioned in the IoTAgent to map their attributes to more than one entity, declaring the target\nentity through the Configuration or Device provisioning APIs.\n\n##### Bidirectionality plugin (bidirectional)\nThis plugin allows the devices with composite values an expression to update the original values in the devices when\nthe composite expressions are updated in the Context Broker. This behavior is achieved through the use of subscriptions.\n\nIoTAs using this plugins should also define a notification handler to handle incoming values. This handler will be\nintercepted by the plugin, so the mapped values are included in the updated notification.\n\nWhen a device is provisioned with bidirectional attributes, the IoTAgent subscribes to changes in that attribute. When a\nchange notification for that attribute arrives to the IoTA, it applies the transformation defined in the device provisioning\npayload to the notification, and calls the underlying notification handler with the transformed entity.\n\nThe following `attributes` section shows an example of the plugin configuration:\n```\n      \"attributes\": [\n        {\n          \"name\":\"location\",\n          \"type\":\"geo:point\",\n          \"expression\": \"${latitude}, ${longitude}\",\n          \"reverse\": [\n            {\n              \"object_id\":\"longitude\",\n              \"type\": \"string\",\n              \"expression\": \"${trim(substr(@location, indexOf(@location, \\\",\\\") + 1, length(@location)))}\"\n            },\n            {\n              \"object_id\":\"latitude\",\n              \"type\": \"string\",\n              \"expression\": \"${trim(substr(@location, 0, indexOf(@location, \\\",\\\")))}\"\n            }\n          ]\n        }\n      ],\n```\nFor each attribute that would have bidirectionality, a new field `reverse` must be configured. This field will contain\nan array of fields that will be created based on the notifications content. The expression notification can contain\nany attribute of the same entity as the bidirectional attribute; declaring them in the expressions will add them to\nthe subscription payload.\n\nFor each attribute in the `reverse` array, an expression must be defined to calculate its value based on the notification\nattributes. This value will be passed to the underlying protocol with the `object_id` name. Details about how the value\nis then progressed to the device are protocol-specific.\n\n### <a name=\"datamigration\"/> Old IoTAgent data migration\nIn order to ease the transition from the old IoTAgent implementation (formerly known as IDAS) to the new Node.js based\nimplementations, a data migration tool has been developed. This data migration tool has been integrated as a command\nin the IoTAgent command line tester.\n\nIn order to perform a full migration, follow this steps:\n* From the project root, start the command line tester:\n<pre>\nbin/iotAgentTester.js\n</pre>\n\n* Configure the MongoDB host and port, and the origin Database (that holds the data to be migrated):\n<pre>\nconfigMigration localhost 27017 originDB\n</pre>\n\n* Launch the migration, using the special value \"*\" as service and subservice\n<pre>\nmigrate targetDB * *\n</pre>\n\nSome warnings may appear with the \"Attribute [_id] was not found for item translation\" message during the migration.\nThey show the values existing in the original DB that had no translation for the target DB.\n\nIf you want to restrict the migration for certain services and subservices, just substitute the '*' value for the particular\nservice and subservice you want to use.\n\n## <a name=\"librarytesting\"/> Testing\n### Agent Console\nA command line client to experiment with the library is packed with it. The command line client can be started using the following command:\n```\nbin/agentConsole.js\n```\nThe client offers an API similar to the one offered by the library: it can start and stop an IoT agent, register and unregister devices, send measures mimicking the device and receive updates of the device data. Take into account that, by default, the console uses the same `config.js` file than the IoT Agent.\n\nThe command line client creates a console that offers the following options:\n\n```\nstressInit\n\n\tStart recording a stress batch.\n\nstressCommit <delay> <times> <threads> <initTime>\n\n\tExecutes the recorded batch as many times as requested, with delay (ms) between commands.\n\tThe \"threads\" parameter indicates how many agents will repeat that same sequence. The \"initTime\" (ms)\n\tparameter indicates the mean of the random initial waiting times for each agent.\n\nexit\n\n\tExit from the command line.\n\nstart\n\n\tStart the IoT Agent\n\nstop\n\n\tStop the IoT Agent\n\nregister <id> <type>\n\n\tRegister a new device in the IoT Agent. The attributes to register will be extracted from the\n\ttype configuration\n\nunregister <id> <type>\n\n\tUnregister the selected device\n\nshowConfig\n\n\tShow the current configuration file\n\nconfig <newConfig>\n\n\tChange the configuration file to a new one\n\nupdatevalue <deviceId> <deviceType> <attributes>\n\n\tUpdate a device value in the Context Broker. The attributes should be triads with the following\n\tformat: \"name/type/value\" sepparated by commas.\n\nlistdevices\n\n\tList all the devices that have been registered in this IoT Agent session\n\n```\n### Agent tester\n#### Command line testing\nThe library also offers a Context Broker and IoT Agent client that can be used to:\n* Simulate operations to the Context Broker used by the IoT Agent, triggering Context Provider forwardings for lazy attributes and checking the appropriate values for active ones.\n* Simulate operations to the Device Provisioning API and Configuration API of the IoT Agent.\n\nThe tester can be started with the following command, from the root folder of the project:\n```\nbin/iotAgentTester.js\n```\nFrom the command line, the `help` command can be used to show a description of the currently supported features. These are the following:\n```\nstressInit\n\n\tStart recording a stress batch.\n\nstressCommit <delay> <times> <threads> <initTime>\n\n\tExecutes the recorded batch as many times as requested, with delay (ms) between commands.\n\tThe \"threads\" parameter indicates how many agents will repeat that same sequence. The \"initTime\" (ms)\n\tparameter indicates the mean of the random initial waiting times for each agent.\n\nexit\n\n\tExit from the command line.\n\nupdate <entity> <type> <attributes>\n\n\tUpdate the values of the defined set of attributes, using the following format: name#type=value(|name#type=value)*\n\nappend <entity> <type> <attributes>\n\n\tAppend a new Entity with the defined set of attributes, using the following format: name:type=value(,name:type=value)*\n\nquery <entity> <type>\n\n\tGet all the information on the selected object.\n\nqueryAttr <entity> <type> <attributes>\n\n\tGet information on the selected object for the selected attributes.\n\ndiscover <entity> <type>\n\n\tGet all the context providers for a entity and type.\n\nconfigCb <host> <port> <service> <subservice>\n\n\tConfig a new host and port for the remote Context Broker.\n\nshowConfigCb\n\n\tShow the current configuration of the client for the Context Broker.\n\nconfigIot <host> <port> <service> <subservice>\n\n\tConfig a new host and port for the remote IoT Agent.\n\nshowConfigIot\n\n\tShow the current configuration of the client for the IoT Agent.\n\nprovision <filename>\n\n\tProvision a new device using the Device Provisioning API. The device configuration is\n\tread from the file specified in the \"filename\" parameter.\n\nprovisionGroup <template> <data> <type>\n\n\tProvision a group of devices with the selected template, taking the information needed to\n\tfill the template from a CSV with two columns, DEVICE_ID and DEVICE_NAME. The third parameter, type\n\twill be used to replace the DEVICE_TYPE field in the template. All the devices will be provisioned\n\tto the same IoT Agent, once the templates have been fulfilled.\n\nlistProvisioned\n\n\tList all the provisioned devices in an IoT Agent.\n\nremoveProvisioned <deviceId>\n\n\tRemove the selected provisioned device from the IoT Agent, specified by its Device ID.\n\naddGroup <filename>\n\n\tAdd a new device group to the specified IoT Agent through the Configuration API. The\n\tbody is taken from the file specified in the \"filename\" parameter.\n\nlistGroups\n\n\tList all the device groups created in the selected IoT Agent for the configured service\n\nremoveGroup <apiKey> <resource>\n\n\tRemove the device group corresponding to the current configured subservice.\n\nauthenticate <host> <port> <user> <password> <service>\n\n\tAuthenticates to the given authentication server, and use the token in subsequent requests.\n\nsetProtocol <protocol>\n\n\tSets the protocol to use in the requests (http or https). Defaults to http.\n\nconfigMigration <host> <port> <originDb>\n\n\tSets the configuration for a migration between a C++ IoTA and a Node.js one.\n\nshowConfigMigration\n\n\tShows the current migration configuration.\n\naddProtocols <protocols>\n\n\tAdd a protocol translation table, in the following format:\n\t\tprotocolOrigin1=protocolTarget1;protocolOrigin2=protocolTarget2...\n\n\nmigrate <targetDb> <service> <subservice>\n\n\tMigrate all the devices and services for the selected service and subservice into the\n\tspecified Mongo database. To perform the migration for all the services or all the\n\tsubservices, use the \"*\" value.\n\n```\n\nThe agent session stores transient configuration data about the target Context Broker and the target IoT Agent. This configuration is independent, and can be checked with the `showConfigCb` and `showConfigIot` commands, respectively. Their values can be changed with the `configCb` and `configIot` commands respectively. The new configurations will be deleted upon startup.\n\n#### Creating specialized testers\nThe command line testing tools make use of the [command-node Node.js library](https://github.com/telefonicaid/command-shell-lib) for command line\nutils. In order to help creating testing tools for IoTAgents of specific protocols, all the commands of the library tester are offered as a array\nthat can be directly imported into other Command Line tools, using the following steps:\n\n* Require the ´iotagent-node-lib´ command line module in your command line tool:\n```\n  var iotaCommands = require('iotagent-node-lib').commandLine;\n```\n* Initialize the command line utils (the initialization function takes two arguments, that will be explained in detail\nbelow:\n```\niotaCommands.init(configCb, configIot);\n```\n* Add the IOTA Lib commands to your array of commands\n```\ncommands = commands.concat(commands, iotaCommands.commands);\n```\n* Execute the command line interpreter as usual:\n```\nclUtils.initialize(commandLine.commands, 'IoT Agent tester> ');\n```\n\nThe command line module makes use of two configuration objects. Both can be shown and edited in the command line using the\nprovided commands, but a default value must be present.\n\nThe Context Broker configuration object holds all the information about the Context Broker where the IoT Agent to be tested\nis connected. It MUST contain the following attributes:\n* **host**: host where the Context Broker instance is located.\n* **port**: port where the Context Broker instance is listening.\n* **service**: service that will be used in all the NGSI operations.\n* **subservice**: service that will be used in all the NGSI operations.\n\nThe IoT Agent configuration object holds information about the IoT Agent that is being tested. It MUST contain the following\nattributes:\n* **host**: host where the IoT Agent instance is located.\n* **port**: port where the IoT Agent instance is listening.\n* **service**: service that will be used to group devices and device information.\n* **subservice**: subservice that will be used to group devices and device information.\n\n##  <a name=\"development\"/> Development documentation\n\nInformation about developing for the IoTAgent Library can be found at the corresponding section of the [User & Programmers Manual](docs/usermanual.md).\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/telefonicaid/iotagent-node-lib.git"
  },
  "scripts": {
    "test": "grunt test"
  },
  "version": "2.4.0-next"
}
